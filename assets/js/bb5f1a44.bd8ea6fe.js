"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[6658],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(a),m=r,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return a?n.createElement(h,s(s({ref:t},c),{},{components:a})):n.createElement(h,s({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5507:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={sidebar_position:2,title:"Data Fetching Patterns",description:"Learn about common data fetching patterns in React and Next.js."},s=void 0,o={unversionedId:"app/building-your-application/data-fetching/patterns",id:"app/building-your-application/data-fetching/patterns",title:"Data Fetching Patterns",description:"Learn about common data fetching patterns in React and Next.js.",source:"@site/docs/02-app/01-building-your-application/02-data-fetching/02-patterns.mdx",sourceDirName:"02-app/01-building-your-application/02-data-fetching",slug:"/app/building-your-application/data-fetching/patterns",permalink:"/docs/app/building-your-application/data-fetching/patterns",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02-app/01-building-your-application/02-data-fetching/02-patterns.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Data Fetching Patterns",description:"Learn about common data fetching patterns in React and Next.js."},sidebar:"tutorialSidebar",previous:{title:"Fetching, Caching, and Revalidating",permalink:"/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating"},next:{title:"Forms and Mutations",permalink:"/docs/app/building-your-application/data-fetching/forms-and-mutations"}},l={},p=[{value:"Fetching Data on the Server",id:"fetching-data-on-the-server",level:3},{value:"Fetching Data Where It&#39;s Needed",id:"fetching-data-where-its-needed",level:3},{value:"Streaming",id:"streaming",level:3},{value:"Parallel and Sequential Data Fetching",id:"parallel-and-sequential-data-fetching",level:3},{value:"Sequential Data Fetching",id:"sequential-data-fetching",level:4},{value:"Parallel Data Fetching",id:"parallel-data-fetching",level:4},{value:"Preloading Data",id:"preloading-data",level:3},{value:"Using React <code>cache</code>, <code>server-only</code>, and the Preload Pattern",id:"using-react-cache-server-only-and-the-preload-pattern",level:3}],c=(d="Image",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var d;const u={toc:p},m="wrapper";function h(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"There are a few recommended patterns and best practices for fetching data in React and Next.js. This page will go over some of the most common patterns and how to use them."),(0,r.kt)("h3",{id:"fetching-data-on-the-server"},"Fetching Data on the Server"),(0,r.kt)("p",null,"Whenever possible, we recommend fetching data on the server. This allows you to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Have direct access to backend data resources (e.g. databases)."),(0,r.kt)("li",{parentName:"ul"},"Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client."),(0,r.kt)("li",{parentName:"ul"},"Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the ",(0,r.kt)("a",{parentName:"li",href:"https://vercel.com/blog/how-react-18-improves-application-performance"},"work on the main thread")," on the client."),(0,r.kt)("li",{parentName:"ul"},"Perform multiple data fetches with single round-trip instead of multiple individual requests on the client."),(0,r.kt)("li",{parentName:"ul"},"Reduce client-server ",(0,r.kt)("a",{parentName:"li",href:"#parallel-and-sequential-data-fetching"},"waterfalls"),"."),(0,r.kt)("li",{parentName:"ul"},"Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.")),(0,r.kt)("p",null,"You can fetch data on the server using Server Components, ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/route-handlers"},"Route Handlers"),", and ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/data-fetching/forms-and-mutations"},"Server Actions"),"."),(0,r.kt)("h3",{id:"fetching-data-where-its-needed"},"Fetching Data Where It's Needed"),(0,r.kt)("p",null,"If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor forward props between components. Instead, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch")," or React ",(0,r.kt)("inlineCode",{parentName:"p"},"cache")," in the component that needs the data without worrying about the performance implications of making multiple requests for the same data."),(0,r.kt)("p",null,"This is possible because ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch")," requests are automatically memoized. Learn more about ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/caching#request-memoization"},"request memoization")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Good to know"),": This also applies to layouts, since it's not possible to pass data between a parent layout and its children.")),(0,r.kt)("h3",{id:"streaming"},"Streaming"),(0,r.kt)("p",null,"Streaming and ",(0,r.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/Suspense"},"Suspense")," are React features that allow you to progressively render and incrementally stream rendered units of the UI to the client."),(0,r.kt)("p",null,"With Server Components and ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/pages-and-layouts"},"nested layouts"),", you're able to instantly render parts of the page that do not specifically require data, and show a ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming"},"loading state")," for parts of the page that are fetching data. This means the user does not have to wait for the entire page to load before they can start interacting with it."),(0,r.kt)(c,{alt:"Server Rendering with Streaming",srcLight:"/docs/light/server-rendering-with-streaming.png",srcDark:"/docs/dark/server-rendering-with-streaming.png",width:"1600",height:"785",mdxType:"Image"}),(0,r.kt)("p",null,"To learn more about Streaming and Suspense, see the ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming"},"Loading UI")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense"},"Streaming and Suspense")," pages."),(0,r.kt)("h3",{id:"parallel-and-sequential-data-fetching"},"Parallel and Sequential Data Fetching"),(0,r.kt)("p",null,"When fetching data inside React components, you need to be aware of two data fetching patterns: Parallel and Sequential."),(0,r.kt)(c,{alt:"Sequential and Parallel Data Fetching",srcLight:"/docs/light/sequential-parallel-data-fetching.png",srcDark:"/docs/dark/sequential-parallel-data-fetching.png",width:"1600",height:"525",mdxType:"Image"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"With ",(0,r.kt)("strong",{parentName:"li"},"sequential data fetching"),", requests in a route are dependent on each other and therefore create waterfalls. There may be cases where you want this pattern because one fetch depends on the result of the other, or you want a condition to be satisfied before the next fetch to save resources. However, this behavior can also be unintentional and lead to longer loading times."),(0,r.kt)("li",{parentName:"ul"},"With ",(0,r.kt)("strong",{parentName:"li"},"parallel data fetching"),", requests in a route are eagerly initiated and will load data at the same time. This reduces client-server waterfalls and the total time it takes to load data.")),(0,r.kt)("h4",{id:"sequential-data-fetching"},"Sequential Data Fetching"),(0,r.kt)("p",null,"If you have nested components, and each component fetches its own data, Then, data fetching will happen sequentially if those data requests are different (this doesn't apply to requests for the same data as they are automatically ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/caching#request-memoization"},"memoized"),")."),(0,r.kt)("p",null,"For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Playlists")," component will only start fetching data once the ",(0,r.kt)("inlineCode",{parentName:"p"},"Artist")," component has finished fetching data because ",(0,r.kt)("inlineCode",{parentName:"p"},"Playlists")," depends on the ",(0,r.kt)("inlineCode",{parentName:"p"},"artistID")," prop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'filename="app/artist/page.tsx" switcher',filename:'"app/artist/page.tsx"',switcher:!0},"// ...\n\nasync function Playlists({ artistID }: { artistID: string }) {\n    // Wait for the playlists\n    const playlists = await getArtistPlaylists(artistID);\n\n    return (\n        <ul>\n            {playlists.map((playlist) => (\n                <li key={playlist.id}>{playlist.name}</li>\n            ))}\n        </ul>\n    );\n}\n\nexport default async function Page({\n    params: { username },\n}: {\n    params: { username: string };\n}) {\n    // Wait for the artist\n    const artist = await getArtist(username);\n\n    return (\n        <>\n            <h1>{artist.name}</h1>\n            <Suspense fallback={<div>Loading...</div>}>\n                <Playlists artistID={artist.id} />\n            </Suspense>\n        </>\n    );\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'filename="app/artist/page.js" switcher',filename:'"app/artist/page.js"',switcher:!0},"// ...\n\nasync function Playlists({ artistID }) {\n    // Wait for the playlists\n    const playlists = await getArtistPlaylists(artistID);\n\n    return (\n        <ul>\n            {playlists.map((playlist) => (\n                <li key={playlist.id}>{playlist.name}</li>\n            ))}\n        </ul>\n    );\n}\n\nexport default async function Page({ params: { username } }) {\n    // Wait for the artist\n    const artist = await getArtist(username);\n\n    return (\n        <>\n            <h1>{artist.name}</h1>\n            <Suspense fallback={<div>Loading...</div>}>\n                <Playlists artistID={artist.id} />\n            </Suspense>\n        </>\n    );\n}\n")),(0,r.kt)("p",null,"In cases like this, you can use ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming"},(0,r.kt)("inlineCode",{parentName:"a"},"loading.js"))," (for route segments) or ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense"},"React ",(0,r.kt)("inlineCode",{parentName:"a"},"<Suspense>"))," (for nested components) to show an instant loading state while React streams in the result."),(0,r.kt)("p",null,"This will prevent the whole route from being blocked by data fetching, and the user will be able to interact with the parts of the page that are not blocked."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Blocking Data Requests:")),(0,r.kt)("p",{parentName:"blockquote"},'An alternative approach to prevent waterfalls is to fetch data globally, at the root of your application, but this will block rendering for all route segments beneath it until the data has finished loading. This can be described as "all or nothing" data fetching. Either you have the entire data for your page or application, or none.'),(0,r.kt)("p",{parentName:"blockquote"},"Any fetch requests with ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," will block rendering and data fetching for the entire tree beneath it, unless they are wrapped in a ",(0,r.kt)("inlineCode",{parentName:"p"},"<Suspense>")," boundary or ",(0,r.kt)("inlineCode",{parentName:"p"},"loading.js")," is used. Another alternative is use ",(0,r.kt)("a",{parentName:"p",href:"#parallel-data-fetching"},"parallel data fetching")," or the ",(0,r.kt)("a",{parentName:"p",href:"#preloading-data"},"preload pattern"),".")),(0,r.kt)("h4",{id:"parallel-data-fetching"},"Parallel Data Fetching"),(0,r.kt)("p",null,"To fetch data in parallel, you can eagerly initiate requests by defining them outside the components that use the data, then calling them from inside the component. This saves time by initiating both requests in parallel, however, the user won't see the rendered result until both promises are resolved."),(0,r.kt)("p",null,"In the example below, the ",(0,r.kt)("inlineCode",{parentName:"p"},"getArtist")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getArtistAlbums")," functions are defined outside the ",(0,r.kt)("inlineCode",{parentName:"p"},"Page")," component, then called inside the component, and we wait for both promises to resolve:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'filename="app/artist/[username]/page.tsx" switcher',filename:'"app/artist/[username]/page.tsx"',switcher:!0},'import Albums from "./albums";\n\nasync function getArtist(username: string) {\n    const res = await fetch(`https://api.example.com/artist/${username}`);\n    return res.json();\n}\n\nasync function getArtistAlbums(username: string) {\n    const res = await fetch(\n        `https://api.example.com/artist/${username}/albums`,\n    );\n    return res.json();\n}\n\nexport default async function Page({\n    params: { username },\n}: {\n    params: { username: string };\n}) {\n    // Initiate both requests in parallel\n    const artistData = getArtist(username);\n    const albumsData = getArtistAlbums(username);\n\n    // Wait for the promises to resolve\n    const [artist, albums] = await Promise.all([artistData, albumsData]);\n\n    return (\n        <>\n            <h1>{artist.name}</h1>\n            <Albums list={albums}></Albums>\n        </>\n    );\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'filename="app/artist/[username]/page.js" switcher',filename:'"app/artist/[username]/page.js"',switcher:!0},'import Albums from "./albums";\n\nasync function getArtist(username) {\n    const res = await fetch(`https://api.example.com/artist/${username}`);\n    return res.json();\n}\n\nasync function getArtistAlbums(username) {\n    const res = await fetch(\n        `https://api.example.com/artist/${username}/albums`,\n    );\n    return res.json();\n}\n\nexport default async function Page({ params: { username } }) {\n    // Initiate both requests in parallel\n    const artistData = getArtist(username);\n    const albumsData = getArtistAlbums(username);\n\n    // Wait for the promises to resolve\n    const [artist, albums] = await Promise.all([artistData, albumsData]);\n\n    return (\n        <>\n            <h1>{artist.name}</h1>\n            <Albums list={albums}></Albums>\n        </>\n    );\n}\n')),(0,r.kt)("p",null,"To improve the user experience, you can add a ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming"},"Suspense Boundary")," to break up the rendering work and show part of the result as soon as possible."),(0,r.kt)("h3",{id:"preloading-data"},"Preloading Data"),(0,r.kt)("p",null,"Another way to prevent waterfalls is to use the preload pattern. You can optionally create a ",(0,r.kt)("inlineCode",{parentName:"p"},"preload")," function to further optimize parallel data fetching. With this approach, you don't have to pass promises down as props. The ",(0,r.kt)("inlineCode",{parentName:"p"},"preload")," function can also have any name as it's a pattern, not an API."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'filename="components/Item.tsx" switcher',filename:'"components/Item.tsx"',switcher:!0},'import { getItem } from "@/utils/get-item";\n\nexport const preload = (id: string) => {\n    // void evaluates the given expression and returns undefined\n    // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n    void getItem(id);\n};\nexport default async function Item({ id }: { id: string }) {\n    const result = await getItem(id);\n    // ...\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'filename="components/Item.js" switcher',filename:'"components/Item.js"',switcher:!0},'import { getItem } from "@/utils/get-item";\n\nexport const preload = (id) => {\n    // void evaluates the given expression and returns undefined\n    // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n    void getItem(id);\n};\nexport default async function Item({ id }) {\n    const result = await getItem(id);\n    // ...\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'filename="app/item/[id]/page.tsx" switcher',filename:'"app/item/[id]/page.tsx"',switcher:!0},'import Item, { preload, checkIsAvailable } from "@/components/Item";\n\nexport default async function Page({\n    params: { id },\n}: {\n    params: { id: string };\n}) {\n    // starting loading item data\n    preload(id);\n    // perform another asynchronous task\n    const isAvailable = await checkIsAvailable();\n\n    return isAvailable ? <Item id={id} /> : null;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'filename="app/item/[id]/page.js" switcher',filename:'"app/item/[id]/page.js"',switcher:!0},'import Item, { preload, checkIsAvailable } from "@/components/Item";\n\nexport default async function Page({ params: { id } }) {\n    // starting loading item data\n    preload(id);\n    // perform another asynchronous task\n    const isAvailable = await checkIsAvailable();\n\n    return isAvailable ? <Item id={id} /> : null;\n}\n')),(0,r.kt)("h3",{id:"using-react-cache-server-only-and-the-preload-pattern"},"Using React ",(0,r.kt)("inlineCode",{parentName:"h3"},"cache"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"server-only"),", and the Preload Pattern"),(0,r.kt)("p",null,"You can combine the ",(0,r.kt)("inlineCode",{parentName:"p"},"cache")," function, the ",(0,r.kt)("inlineCode",{parentName:"p"},"preload")," pattern, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"server-only")," package to create a data fetching utility that can be used throughout your app."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'filename="utils/get-item.ts" switcher',filename:'"utils/get-item.ts"',switcher:!0},'import { cache } from "react";\nimport "server-only";\n\nexport const preload = (id: string) => {\n    void getItem(id);\n};\n\nexport const getItem = cache(async (id: string) => {\n    // ...\n});\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'filename="utils/get-item.js" switcher',filename:'"utils/get-item.js"',switcher:!0},'import { cache } from "react";\nimport "server-only";\n\nexport const preload = (id) => {\n    void getItem(id);\n};\n\nexport const getItem = cache(async (id) => {\n    // ...\n});\n')),(0,r.kt)("p",null,"With this approach, you can eagerly fetch data, cache responses, and guarantee that this data fetching ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment"},"only happens on the server"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"utils/get-item")," exports can be used by Layouts, Pages, or other components to give them control over when an item's data is fetched."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Good to know:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"We recommend using the ",(0,r.kt)("a",{parentName:"li",href:"/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment"},(0,r.kt)("inlineCode",{parentName:"a"},"server-only")," package")," to make sure server data fetching functions are never used on the client."))))}h.isMDXComponent=!0}}]);