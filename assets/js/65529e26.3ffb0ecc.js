"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[5413],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3216:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:3,title:"Incremental Static Regeneration (ISR)",description:"Learn how to create or update static pages at runtime with Incremental Static Regeneration."},o=void 0,s={unversionedId:"pages/building-your-application/rendering/incremental-static-regeneration",id:"pages/building-your-application/rendering/incremental-static-regeneration",title:"Incremental Static Regeneration (ISR)",description:"Learn how to create or update static pages at runtime with Incremental Static Regeneration.",source:"@site/docs/03-pages/01-building-your-application/02-rendering/03-incremental-static-regeneration.mdx",sourceDirName:"03-pages/01-building-your-application/02-rendering",slug:"/pages/building-your-application/rendering/incremental-static-regeneration",permalink:"/docs/pages/building-your-application/rendering/incremental-static-regeneration",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-pages/01-building-your-application/02-rendering/03-incremental-static-regeneration.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Incremental Static Regeneration (ISR)",description:"Learn how to create or update static pages at runtime with Incremental Static Regeneration."},sidebar:"nextJsSidebar",previous:{title:"Static Site Generation (SSG)",permalink:"/docs/pages/building-your-application/rendering/static-site-generation"},next:{title:"Automatic Static Optimization",permalink:"/docs/pages/building-your-application/rendering/automatic-static-optimization"}},l={},p=[{value:"On-Demand Revalidation",id:"on-demand-revalidation",level:2},{value:"Using On-Demand Revalidation",id:"using-on-demand-revalidation",level:3},{value:"Testing on-Demand ISR during development",id:"testing-on-demand-isr-during-development",level:3},{value:"Error handling and revalidation",id:"error-handling-and-revalidation",level:2},{value:"Self-hosting ISR",id:"self-hosting-isr",level:2},{value:"Version History",id:"version-history",level:2}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Examples"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://nextjs.org/commerce"},"Next.js Commerce")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://reactions-demo.vercel.app/"},"GitHub Reactions Demo")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://static-tweet.vercel.app/"},"Static Tweet Demo")))),(0,r.kt)("p",null,"Next.js allows you to create or update static pages ",(0,r.kt)("em",{parentName:"p"},"after")," you\u2019ve built your site. Incremental Static Regeneration (ISR) enables you to use static-generation on a per-page basis, ",(0,r.kt)("strong",{parentName:"p"},"without needing to rebuild the entire site"),". With ISR, you can retain the benefits of static while scaling to millions of pages."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Good to know"),": The ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/api-reference/edge"},(0,r.kt)("inlineCode",{parentName:"a"},"edge")," runtime")," is currently not compatible with ISR, although you can leverage ",(0,r.kt)("inlineCode",{parentName:"p"},"stale-while-revalidate")," by setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"cache-control")," header manually.")),(0,r.kt)("p",null,"To use ISR, add the ",(0,r.kt)("inlineCode",{parentName:"p"},"revalidate")," prop to ",(0,r.kt)("inlineCode",{parentName:"p"},"getStaticProps"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'function Blog({ posts }) {\n    return (\n        <ul>\n            {posts.map((post) => (\n                <li key={post.id}>{post.title}</li>\n            ))}\n        </ul>\n    );\n}\n\n// This function gets called at build time on server-side.\n// It may be called again, on a serverless function, if\n// revalidation is enabled and a new request comes in\nexport async function getStaticProps() {\n    const res = await fetch("https://.../posts");\n    const posts = await res.json();\n\n    return {\n        props: {\n            posts,\n        },\n        // Next.js will attempt to re-generate the page:\n        // - When a request comes in\n        // - At most once every 10 seconds\n        revalidate: 10, // In seconds\n    };\n}\n\n// This function gets called at build time on server-side.\n// It may be called again, on a serverless function, if\n// the path has not been generated.\nexport async function getStaticPaths() {\n    const res = await fetch("https://.../posts");\n    const posts = await res.json();\n\n    // Get the paths we want to pre-render based on posts\n    const paths = posts.map((post) => ({\n        params: { id: post.id },\n    }));\n\n    // We\'ll pre-render only these paths at build time.\n    // { fallback: \'blocking\' } will server-render pages\n    // on-demand if the path doesn\'t exist.\n    return { paths, fallback: "blocking" };\n}\n\nexport default Blog;\n')),(0,r.kt)("p",null,"When a request is made to a page that was pre-rendered at build time, it will initially show the cached page."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Any requests to the page after the initial request and before 10 seconds are also cached and instantaneous."),(0,r.kt)("li",{parentName:"ul"},"After the 10-second window, the next request will still show the cached (stale) page"),(0,r.kt)("li",{parentName:"ul"},"Next.js triggers a regeneration of the page in the background."),(0,r.kt)("li",{parentName:"ul"},"Once the page generates successfully, Next.js will invalidate the cache and show the updated page. If the background regeneration fails, the old page would still be unaltered.")),(0,r.kt)("p",null,"When a request is made to a path that hasn\u2019t been generated, Next.js will server-render the page on the first request. Future requests will serve the static file from the cache. ISR on Vercel ",(0,r.kt)("a",{parentName:"p",href:"https://vercel.com/docs/concepts/next.js/incremental-static-regeneration?utm_source=next-site&utm_medium=docs&utm_campaign=next-website"},"persists the cache globally and handles rollbacks"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Good to know"),": Check if your upstream data provider has caching enabled by default. You might need to disable (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"useCdn: false"),"), otherwise a revalidation won't be able to pull fresh data to update the ISR cache. Caching can occur at a CDN (for an endpoint being requested) when it returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cache-Control")," header.")),(0,r.kt)("h2",{id:"on-demand-revalidation"},"On-Demand Revalidation"),(0,r.kt)("p",null,"If you set a ",(0,r.kt)("inlineCode",{parentName:"p"},"revalidate")," time of ",(0,r.kt)("inlineCode",{parentName:"p"},"60"),", all visitors will see the same generated version of your site for one minute. The only way to invalidate the cache is from someone visiting that page after the minute has passed."),(0,r.kt)("p",null,"Starting with ",(0,r.kt)("inlineCode",{parentName:"p"},"v12.2.0"),", Next.js supports On-Demand Incremental Static Regeneration to manually purge the Next.js cache for a specific page. This makes it easier to update your site when:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Content from your headless CMS is created or updated"),(0,r.kt)("li",{parentName:"ul"},"Ecommerce metadata changes (price, description, category, reviews, etc.)")),(0,r.kt)("p",null,"Inside ",(0,r.kt)("inlineCode",{parentName:"p"},"getStaticProps"),", you do not need to specify ",(0,r.kt)("inlineCode",{parentName:"p"},"revalidate")," to use on-demand revalidation. If ",(0,r.kt)("inlineCode",{parentName:"p"},"revalidate")," is omitted, Next.js will use the default value of ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," (no revalidation) and only revalidate the page on-demand when ",(0,r.kt)("inlineCode",{parentName:"p"},"revalidate()")," is called."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Good to know"),": ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/middleware"},"Middleware")," won't be executed for On-Demand ISR requests. Instead, call ",(0,r.kt)("inlineCode",{parentName:"p"},"revalidate()")," on the ",(0,r.kt)("em",{parentName:"p"},"exact")," path that you want revalidated. For example, if you have ",(0,r.kt)("inlineCode",{parentName:"p"},"pages/blog/[slug].js")," and a rewrite from ",(0,r.kt)("inlineCode",{parentName:"p"},"/post-1")," -> ",(0,r.kt)("inlineCode",{parentName:"p"},"/blog/post-1"),", you would need to call ",(0,r.kt)("inlineCode",{parentName:"p"},"res.revalidate('/blog/post-1')"),".")),(0,r.kt)("h3",{id:"using-on-demand-revalidation"},"Using On-Demand Revalidation"),(0,r.kt)("p",null,"First, create a secret token only known by your Next.js app. This secret will be used to prevent unauthorized access to the revalidation API Route. You can access the route (either manually or with a webhook) with the following URL structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'filename="Terminal"',filename:'"Terminal"'},"https://<your-site.com>/api/revalidate?secret=<token>\n")),(0,r.kt)("p",null,"Next, add the secret as an ",(0,r.kt)("a",{parentName:"p",href:"/docs/pages/building-your-application/configuring/environment-variables"},"Environment Variable")," to your application. Finally, create the revalidation API Route:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'filename="pages/api/revalidate.js"',filename:'"pages/api/revalidate.js"'},'export default async function handler(req, res) {\n    // Check for secret to confirm this is a valid request\n    if (req.query.secret !== process.env.MY_SECRET_TOKEN) {\n        return res.status(401).json({ message: "Invalid token" });\n    }\n\n    try {\n        // this should be the actual path not a rewritten path\n        // e.g. for "/blog/[slug]" this should be "/blog/post-1"\n        await res.revalidate("/path-to-revalidate");\n        return res.json({ revalidated: true });\n    } catch (err) {\n        // If there was an error, Next.js will continue\n        // to show the last successfully generated page\n        return res.status(500).send("Error revalidating");\n    }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://on-demand-isr.vercel.app"},"View our demo")," to see on-demand revalidation in action and provide feedback."),(0,r.kt)("h3",{id:"testing-on-demand-isr-during-development"},"Testing on-Demand ISR during development"),(0,r.kt)("p",null,"When running locally with ",(0,r.kt)("inlineCode",{parentName:"p"},"next dev"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"getStaticProps")," is invoked on every request. To verify your on-demand ISR configuration is correct, you will need to create a ",(0,r.kt)("a",{parentName:"p",href:"/docs/pages/api-reference/next-cli#build"},"production build")," and start the ",(0,r.kt)("a",{parentName:"p",href:"/docs/pages/api-reference/next-cli#production"},"production server"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'filename="Terminal"',filename:'"Terminal"'},"$ next build\n$ next start\n")),(0,r.kt)("p",null,"Then, you can confirm that static pages have successfully revalidated."),(0,r.kt)("h2",{id:"error-handling-and-revalidation"},"Error handling and revalidation"),(0,r.kt)("p",null,"If there is an error inside ",(0,r.kt)("inlineCode",{parentName:"p"},"getStaticProps")," when handling background regeneration, or you manually throw an error, the last successfully generated page will continue to show. On the next subsequent request, Next.js will retry calling ",(0,r.kt)("inlineCode",{parentName:"p"},"getStaticProps"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'export async function getStaticProps() {\n    // If this request throws an uncaught error, Next.js will\n    // not invalidate the currently shown page and\n    // retry getStaticProps on the next request.\n    const res = await fetch("https://.../posts");\n    const posts = await res.json();\n\n    if (!res.ok) {\n        // If there is a server error, you might want to\n        // throw an error instead of returning so that the cache is not updated\n        // until the next successful request.\n        throw new Error(`Failed to fetch posts, received status ${res.status}`);\n    }\n\n    // If the request was successful, return the posts\n    // and revalidate every 10 seconds.\n    return {\n        props: {\n            posts,\n        },\n        revalidate: 10,\n    };\n}\n')),(0,r.kt)("h2",{id:"self-hosting-isr"},"Self-hosting ISR"),(0,r.kt)("p",null,"Incremental Static Regeneration (ISR) works on ",(0,r.kt)("a",{parentName:"p",href:"/docs/pages/building-your-application/deploying#self-hosting"},"self-hosted Next.js sites")," out of the box when you use ",(0,r.kt)("inlineCode",{parentName:"p"},"next start"),"."),(0,r.kt)("p",null,"You can use this approach when deploying to container orchestrators such as ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/"},"Kubernetes")," or ",(0,r.kt)("a",{parentName:"p",href:"https://www.nomadproject.io/"},"HashiCorp Nomad"),". By default, generated assets will be stored in-memory on each pod. This means that each pod will have its own copy of the static files. Stale data may be shown until that specific pod is hit by a request."),(0,r.kt)("p",null,"To ensure consistency across all pods, you can disable in-memory caching. This will inform the Next.js server to only leverage assets generated by ISR in the file system."),(0,r.kt)("p",null,"You can use a shared network mount in your Kubernetes pods (or similar setup) to reuse the same file-system cache between different containers. By sharing the same mount, the ",(0,r.kt)("inlineCode",{parentName:"p"},".next")," folder which contains the ",(0,r.kt)("inlineCode",{parentName:"p"},"next/image")," cache will also be shared and re-used."),(0,r.kt)("p",null,"To disable in-memory caching, set ",(0,r.kt)("inlineCode",{parentName:"p"},"isrMemoryCacheSize")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," in your ",(0,r.kt)("inlineCode",{parentName:"p"},"next.config.js")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'filename="next.config.js"',filename:'"next.config.js"'},"module.exports = {\n    experimental: {\n        // Defaults to 50MB\n        isrMemoryCacheSize: 0, // cache size in bytes\n    },\n};\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Good to know"),": You might need to consider a race condition between multiple pods trying to update the cache at the same time, depending on how your shared mount is configured.")),(0,r.kt)("h2",{id:"version-history"},"Version History"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Version"),(0,r.kt)("th",{parentName:"tr",align:null},"Changes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"v12.2.0")),(0,r.kt)("td",{parentName:"tr",align:null},"On-Demand ISR is stable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"v12.1.0")),(0,r.kt)("td",{parentName:"tr",align:null},"On-Demand ISR added (beta).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"v12.0.0")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://nextjs.org/blog/next-12#bot-aware-isr-fallback"},"Bot-aware ISR fallback")," added.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"v9.5.0")),(0,r.kt)("td",{parentName:"tr",align:null},"Base Path added.")))))}u.isMDXComponent=!0}}]);