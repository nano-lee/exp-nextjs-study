"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[6510],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),h=r,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||i;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},302:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={title:"Server Components",description:"Learn how you can use React Server Components to render parts of your application on the server.",related:{description:"Learn how Next.js caches data and the result of static rendering.",links:["app/building-your-application/caching"]}},o=void 0,s={unversionedId:"app/building-your-application/rendering/server-components",id:"app/building-your-application/rendering/server-components",title:"Server Components",description:"Learn how you can use React Server Components to render parts of your application on the server.",source:"@site/docs/02-app/01-building-your-application/03-rendering/01-server-components.mdx",sourceDirName:"02-app/01-building-your-application/03-rendering",slug:"/app/building-your-application/rendering/server-components",permalink:"/nano-nextjs-study/docs/app/building-your-application/rendering/server-components",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02-app/01-building-your-application/03-rendering/01-server-components.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Server Components",description:"Learn how you can use React Server Components to render parts of your application on the server.",related:{description:"Learn how Next.js caches data and the result of static rendering.",links:["app/building-your-application/caching"]}},sidebar:"tutorialSidebar",previous:{title:"Rendering",permalink:"/nano-nextjs-study/docs/app/building-your-application/rendering/"},next:{title:"Client Components",permalink:"/nano-nextjs-study/docs/app/building-your-application/rendering/client-components"}},l={},d=[{value:"Benefits of Server Rendering",id:"benefits-of-server-rendering",level:2},{value:"Using Server Components in Next.js",id:"using-server-components-in-nextjs",level:2},{value:"How are Server Components rendered?",id:"how-are-server-components-rendered",level:2},{value:"Server Rendering Strategies",id:"server-rendering-strategies",level:2},{value:"Static Rendering (Default)",id:"static-rendering-default",level:3},{value:"Dynamic Rendering",id:"dynamic-rendering",level:3},{value:"Switching to Dynamic Rendering",id:"switching-to-dynamic-rendering",level:4},{value:"Dynamic Functions",id:"dynamic-functions",level:4},{value:"Streaming",id:"streaming",level:3}],p=(c="Image",function(e){return console.warn("Component "+c+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var c;const u={toc:d},h="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"React Server Components allow you to write UI that can be rendered and optionally cached on the server. In Next.js, the rendering work is further split by route segments to enable streaming and partial rendering, and there are three different server rendering strategies:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#static-rendering-default"},"Static Rendering")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#dynamic-rendering"},"Dynamic Rendering")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#streaming"},"Streaming"))),(0,r.kt)("p",null,"This page will go through how Server Components work, when you might use them, and the different server rendering strategies."),(0,r.kt)("h2",{id:"benefits-of-server-rendering"},"Benefits of Server Rendering"),(0,r.kt)("p",null,"There are a couple of benefits to doing the rendering work on the server, including:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Data Fetching"),": Server Components allow you to move data fetching to the server, closer to your data source. This can improve performance by reducing time it takes to fetch data needed for rendering, and the amount of requests the client needs to make."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Security"),": Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk of exposing them to the client."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Caching"),": By rendering on the server, the result can be cached and reused on subsequent requests and across users. This can improve performance and reduce cost by reducing the amount of rendering and data fetching done on each request."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Bundle Sizes"),": Server Components allow you to keep large dependencies that previously would impact the client JavaScript bundle size on the server. This is beneficial for users with slower internet or less powerful devices, as the client does not have to download, parse and execute any JavaScript for Server Components."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Initial Page Load and ",(0,r.kt)("a",{parentName:"strong",href:"https://web.dev/fcp/"},"First Contentful Paint (FCP)")),": On the server, we can generate HTML to allow users to view the page immediately, without waiting for the client to download, parse and execute the JavaScript needed to render the page."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Search Engine Optimization and Social Network Shareability"),": The rendered HTML can be used by search engine bots to index your pages and social network bots to generate social card previews for your pages."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Streaming"),": Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.")),(0,r.kt)("h2",{id:"using-server-components-in-nextjs"},"Using Server Components in Next.js"),(0,r.kt)("p",null,"By default, Next.js uses Server Components. This allows you to automatically implement server rendering with no additional configuration, and you can opt into using Client Components when needed, see ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/rendering/client-components"},"Client Components"),"."),(0,r.kt)("h2",{id:"how-are-server-components-rendered"},"How are Server Components rendered?"),(0,r.kt)("p",null,"On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual route segments and ",(0,r.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/Suspense"},"Suspense Boundaries"),"."),(0,r.kt)("p",null,"Each chunk is rendered in two steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"React renders Server Components into a special data format called the ",(0,r.kt)("strong",{parentName:"li"},"React Server Component Payload (RSC Payload)"),"."),(0,r.kt)("li",{parentName:"ol"},"Next.js uses the RSC Payload and Client Component JavaScript instructions to render ",(0,r.kt)("strong",{parentName:"li"},"HTML")," on the server.")),(0,r.kt)("p",null,"{/",(0,r.kt)("em",{parentName:"p"}," Rendering Diagram "),"/}"),(0,r.kt)("p",null,"Then, on the client:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only."),(0,r.kt)("li",{parentName:"ol"},"The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM."),(0,r.kt)("li",{parentName:"ol"},"The JavaScript instructions are used to ",(0,r.kt)("a",{parentName:"li",href:"https://react.dev/reference/react-dom/client/hydrateRoot"},"hydrate")," Client Components and make the application interactive.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"What is the React Server Component Payload (RSC)?")),(0,r.kt)("p",{parentName:"blockquote"},"The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"The rendered result of Server Components"),(0,r.kt)("li",{parentName:"ul"},"Placeholders for where Client Components should be rendered and references to their JavaScript files"),(0,r.kt)("li",{parentName:"ul"},"Any props passed from a Server Component to a Client Component"))),(0,r.kt)("h2",{id:"server-rendering-strategies"},"Server Rendering Strategies"),(0,r.kt)("p",null,"There are three subsets of server rendering: Static, Dynamic, and Streaming."),(0,r.kt)("h3",{id:"static-rendering-default"},"Static Rendering (Default)"),(0,r.kt)("p",null,"{/",(0,r.kt)("em",{parentName:"p"}," Static Rendering Diagram "),"/}"),(0,r.kt)("p",null,"With Static Rendering, routes are rendered at ",(0,r.kt)("strong",{parentName:"p"},"build time"),", or in the background after ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#revalidating-data"},"data revalidation"),". The result is cached and can be pushed to a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/docs/Glossary/CDN"},"Content Delivery Network (CDN)"),". This optimization allows you to share the result of the rendering work between users and server requests."),(0,r.kt)("p",null,"Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static blog post or a product page."),(0,r.kt)("h3",{id:"dynamic-rendering"},"Dynamic Rendering"),(0,r.kt)("p",null,"{/",(0,r.kt)("em",{parentName:"p"}," Dynamic Rendering Diagram "),"/}"),(0,r.kt)("p",null,"With Dynamic Rendering, routes are rendered for each user at ",(0,r.kt)("strong",{parentName:"p"},"request time"),"."),(0,r.kt)("p",null,"Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL's search params."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Dynamic Routes with Cached Data")),(0,r.kt)("p",{parentName:"blockquote"},"In most websites, routes are not fully static or fully dynamic - it's a spectrum. For example, you can have e-commerce page that uses cached product data that's revalidated at an interval, but also has uncached, personalized customer data."),(0,r.kt)("p",{parentName:"blockquote"},"In Next.js, you can have dynamically rendered routes that have both cached and uncached data. This is because the RSC Payload and data are cached separately. This allows you to opt into dynamic rendering without worrying about the performance impact of fetching all the data at request time."),(0,r.kt)("p",{parentName:"blockquote"},"Learn more about the ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/caching#full-route-cache"},"full-route cache")," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/caching#data-cache"},"Data Cache"),".")),(0,r.kt)("h4",{id:"switching-to-dynamic-rendering"},"Switching to Dynamic Rendering"),(0,r.kt)("p",null,"During rendering, if a ",(0,r.kt)("a",{parentName:"p",href:"#dynamic-functions"},"dynamic function")," or ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching"},"uncached data request")," is discovered, Next.js will switch to dynamically rendering the whole route. This table summarizes how dynamic functions and data caching affect whether a route is statically or dynamically rendered:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Dynamic Functions"),(0,r.kt)("th",{parentName:"tr",align:null},"Data"),(0,r.kt)("th",{parentName:"tr",align:null},"Route"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Cached"),(0,r.kt)("td",{parentName:"tr",align:null},"Statically Rendered")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Cached"),(0,r.kt)("td",{parentName:"tr",align:null},"Dynamically Rendered")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Not Cached"),(0,r.kt)("td",{parentName:"tr",align:null},"Dynamically Rendered")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Not Cached"),(0,r.kt)("td",{parentName:"tr",align:null},"Dynamically Rendered")))),(0,r.kt)("p",null,"In the table above, for a route to be fully static, all data must be cached. However, you can have a dynamically rendered route that uses both cached and uncached data fetches."),(0,r.kt)("p",null,"As a developer, you do not need to choose between static and dynamic rendering as Next.js will automatically choose the best rendering strategy for each route based on the features and APIs used. Instead, you choose when to ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating"},"cache or revalidate specific data"),", and you may choose to ",(0,r.kt)("a",{parentName:"p",href:"#streaming"},"stream")," parts of your UI."),(0,r.kt)("h4",{id:"dynamic-functions"},"Dynamic Functions"),(0,r.kt)("p",null,"Dynamic functions rely on information that can only be known at request time such as a user's cookies, current requests headers, or the URL's search params. In Next.js, these dynamic functions are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"/docs/app/api-reference/functions/cookies"},(0,r.kt)("inlineCode",{parentName:"a"},"cookies()"))," and ",(0,r.kt)("a",{parentName:"strong",href:"/docs/app/api-reference/functions/headers"},(0,r.kt)("inlineCode",{parentName:"a"},"headers()"))),": Using these in a Server Component will opt the whole route into dynamic rendering at request time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"/docs/app/api-reference/functions/use-search-params"},(0,r.kt)("inlineCode",{parentName:"a"},"useSearchParams()"))),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"In Client Components, it'll skip static rendering and instead render all Client Components up to the nearest parent Suspense boundary on the client."),(0,r.kt)("li",{parentName:"ul"},"We recommend wrapping the Client Component that uses ",(0,r.kt)("inlineCode",{parentName:"li"},"useSearchParams()")," in a ",(0,r.kt)("inlineCode",{parentName:"li"},"<Suspense/>")," boundary. This will allow any Client Components above it to be statically rendered. ",(0,r.kt)("a",{parentName:"li",href:"/docs/app/api-reference/functions/use-search-params#static-rendering"},"Example"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("a",{parentName:"strong",href:"/docs/app/api-reference/file-conventions/page#searchparams-optional"},(0,r.kt)("inlineCode",{parentName:"a"},"searchParams"))),": Using the ",(0,r.kt)("a",{parentName:"li",href:"/docs/app/api-reference/file-conventions/page"},"Pages")," prop will opt the page into dynamic rendering at request time.")),(0,r.kt)("p",null,"Using any of these functions will opt the whole route into dynamic rendering at request time."),(0,r.kt)("h3",{id:"streaming"},"Streaming"),(0,r.kt)(p,{alt:"Diagram showing parallelization of route segments during streaming, showing data fetching, rendering, and hydration of invidiual chunks.",srcLight:"/docs/light/sequential-parallel-data-fetching.png",srcDark:"/docs/dark/sequential-parallel-data-fetching.png",width:"1600",height:"525",mdxType:"Image"}),(0,r.kt)("p",null,"Streaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering."),(0,r.kt)(p,{alt:"Diagram showing partially rendered page on the client, with loading UI for chunks that are being streamed.",srcLight:"/docs/light/server-rendering-with-streaming.png",srcDark:"/docs/dark/server-rendering-with-streaming.png",width:"1600",height:"785",mdxType:"Image"}),(0,r.kt)("p",null,"Streaming is built into the Next.js App Router by default. This helps improve both the initial page loading performance, as well as UI that depends on slower data fetches that would block rendering the whole route. For example, reviews on a product page."),(0,r.kt)("p",null,"You can start streaming route segments using ",(0,r.kt)("inlineCode",{parentName:"p"},"loading.js")," and UI components with ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming"},"React Suspense"),". See the ",(0,r.kt)("a",{parentName:"p",href:"/docs/app/building-your-application/routing/loading-ui-and-streaming"},"Loading UI and Streaming")," section for more information."))}m.isMDXComponent=!0}}]);