---
sidebar_position: 8
title: OpenTelemetry
description: Learn how to instrument your Next.js app with OpenTelemetry.
---

> **Good to know**: This feature is **experimental**, you need to explicitly opt-in by providing `experimental.instrumentationHook = true;` in your `next.config.js`.

Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app.

As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.

We recommend using OpenTelemetry for instrumenting your apps.
It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code.
Read [Official OpenTelemetry docs](https://opentelemetry.io/docs/) for more information about OpenTelemetry and how it works.

This documentation uses terms like _Span_, _Trace_ or _Exporter_ throughout this doc, all of which can be found in [the OpenTelemetry Observability Primer](https://opentelemetry.io/docs/concepts/observability-primer/).

Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.
When you enable OpenTelemetry we will automatically wrap all your code like `getStaticProps` in _spans_ with helpful attributes.

> **Good to know**: We currently support OpenTelemetry bindings only in serverless functions.
> We don't provide any for `edge` or client side code.

## Getting Started

OpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package `@vercel/otel` that helps you get started quickly.
It's not extensible and you should configure OpenTelemetry manually if you need to customize your setup.

### Using `@vercel/otel`

To get started, you must install `@vercel/otel`:

```bash filename="Terminal"
npm install @vercel/otel
```

Next, create a custom [`instrumentation.ts`](/docs/pages/building-your-application/optimizing/instrumentation) (or `.js`) file in the **root directory** of the project (or inside `src` folder if using one):

```ts filename="your-project/instrumentation.ts" switcher
import { registerOTel } from "@vercel/otel";

export function register() {
  registerOTel("next-app");
}
```

```js filename="your-project/instrumentation.js" switcher
import { registerOTel } from "@vercel/otel";

export function register() {
  registerOTel("next-app");
}
```

> **Good to know**
>
> - The `instrumentation` file should be in the root of your project and not inside the `app` or `pages` directory. If you're using the `src` folder, then place the file inside `src` alongside `pages` and `app`.
> - If you use the [`pageExtensions` config option](/docs/pages/api-reference/next-config-js/pageExtensions) to add a suffix, you will also need to update the `instrumentation` filename to match.
> - We have created a basic [with-opentelemetry](https://github.com/vercel/next.js/tree/canary/examples/with-opentelemetry) example that you can use.

### Manual OpenTelemetry configuration

If our wrapper `@vercel/otel` doesn't suit your needs, you can configure OpenTelemetry manually.

Firstly you need to install OpenTelemetry packages:

```bash filename="Terminal"
npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http
```

Now you can initialize `NodeSDK` in your `instrumentation.ts`.
OpenTelemetry APIs are not compatible with edge runtime, so you need to make sure that you are importing them only when `process.env.NEXT_RUNTIME === 'nodejs'`. We recommend creating a new file `instrumentation.node.ts` which you conditionally import only when using node:

```ts filename="instrumentation.ts" switcher
export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    await import("./instrumentation.node.ts");
  }
}
```

```js filename="instrumentation.js" switcher
export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    await import("./instrumentation.node.js");
  }
}
```

```ts filename="instrumentation.node.ts" switcher
import { NodeSDK } from "@opentelemetry/sdk-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { Resource } from "@opentelemetry/resources";
import { SemanticResourceAttributes } from "@opentelemetry/semantic-conventions";
import { SimpleSpanProcessor } from "@opentelemetry/sdk-trace-node";

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: "next-app",
  }),
  spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),
});
sdk.start();
```

```js filename="instrumentation.node.js" switcher
import { NodeSDK } from "@opentelemetry/sdk-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { Resource } from "@opentelemetry/resources";
import { SemanticResourceAttributes } from "@opentelemetry/semantic-conventions";
import { SimpleSpanProcessor } from "@opentelemetry/sdk-trace-node";

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: "next-app",
  }),
  spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),
});
sdk.start();
```

Doing this is equivalent to using `@vercel/otel`, but it's possible to modify and extend.
For example, you could use `@opentelemetry/exporter-trace-otlp-grpc` instead of `@opentelemetry/exporter-trace-otlp-http` or you can specify more resource attributes.

## 계측 테스트하기

오픈텔레메트리가 잘 작동하는지 로컬에서 확인하려면 오픈텔레메트리 수집기가 호환되는 백엔드 서버가 필요합니다. 우리가 제공하는 [오픈텔레메트리 개발 환경](https://github.com/vercel/opentelemetry-collector-dev-setup)을 사용하는 것을 추천합니다.

만약 모든것이 정상적으로 작동한다면, `GET /requested/pathname`으로 라벨링된 루트 서버 스팬을 볼 수 있을 것입니다. 모든 다른 스팬들은 그 아래 중첩되어 보여집니다.

Next.js는 기본으로 보여지는 스팬들보다 더 많은 스팬을 수집합니다. 더 많은 스팬을 보려면 `NEXT_OTEL_VERBOSE=1` 설정을 추가하세요.

## 배포하기

### 오픈텔레메트리 수집기 사용하기

When you are deploying with OpenTelemetry Collector, you can use `@vercel/otel`.
It will work both on Vercel and when self-hosted.
오픈텔레메트리 수집기를 사용하여 배포하는 경우, `@vercel/otel`을 사용할 수 있습니다. Vercel, 직접 배포 모두에서 작동합니다.

#### Vercel에 배포하기

오픈텔레메트리가 Vercel에서 잘 동작하는지 모든 확인을 마쳤습니다.

[Vercel 도큐멘테이션](https://vercel.com/docs/concepts/observability/otel-overview/quickstart)을 따라 연결하세요.

#### 직접 배포하기

다른 플랫폼에 배포하는 것도 간단합니다. Next.js 앱에서 데이터를 수신하고 처리할 오픈텔레메트리 수집기를 실행시키면 됩니다.

[오픈텔레메트리 수집기 시작하기 가이드](https://opentelemetry.io/docs/collector/getting-started/)를 따라 수집기를 설정하고 Next.js 앱에서 데이터를 수신하도록 구성하세요.

수집기를 실행시킨 후에는 각 플랫폼의 배포 가이드를 따라 Next.js 앱을 배포할 수 있습니다.

### 커스텀 수집기

가능하면 오픈텔레메트리 수집기를 사용하세요. 만약 원하는 플랫폼에서 이를 사용할 수 없다면 [오픈텔레메트리 직접 구성하기](/docs/pages/building-your-application/optimizing/open-telemetry#manual-opentelemetry-configuration)를 통해 커스텀 오픈텔레메트리 수집기를 사용할 수 있습니다.

## 커스텀 스팬

[오픈텔레메트리 API](https://opentelemetry.io/docs/instrumentation/js/instrumentation)를 사용하여 커스텀 스팬을 추가할 수 있습니다.

```bash filename="Terminal"
npm install @opentelemetry/api
```

다음 예시는 깃헙에서 스타를 가져오고 `fetchGithubStart`라는 커스텀 스팬을 추가하여 요청 결과를 추적하는 함수를 보여줍니다.

```ts
import { trace } from "@opentelemetry/api";

export async function fetchGithubStars() {
  return await trace
    .getTracer("nextjs-example")
    .startActiveSpan("fetchGithubStars", async (span) => {
      try {
        return await getValue();
      } finally {
        span.end();
      }
    });
}
```

`register` 함수는 새 환경에서 코드가 실행되기 전에 실행됩니다. 이때 새 스팬이 생성되어 수집하는 추적에 추가됩니다.

## Next.js에서 제공하는 기본 스팬

Next.js는 앱 성능에 대한 유용한 인사이트를 제공하기 위해 자동으로 여러 스팬을 계측합니다.

스팬의 속성은 [오픈텔레메트리 시맨틱 컨벤션](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/)을 따릅니다. 여기에 더해 `next` 네임스페이스에 몇 가지 커스텀 속성을 추가했습니다.

- `next.span_name` - 스팬 이름
- `next.span_type` - 각 스팬 타입은 고유한 식별자를 가지고 있습니다.
- `next.route` - 요청 경로 (예: `/[param]/user`).
- `next.page`
  - 앱 라우터에서 사용하는 내부 값입니다.
  - 특별한 파일에 대한 경로로 생각할 수 있습니다. (`page.ts`, `layout.ts`, `loading.ts` 등)
  - It can be used as a unique identifier only when paired with `next.route` because `/layout` can be used to identify both `/(groupA)/layout.ts` and `/(groupB)/layout.ts`
  - `next.route`랑 함께 사용할 때만 고유 식별자로 사용할 수 있습니다. `/layout`의 경우 `/(groupA)/layout.ts`와 `/(groupB)/layout.ts`와 같이 사용하면 고유 식별자가 됩니다.

### `[http.method] [next.route]`

- `next.span_type`: `BaseServer.handleRequest`

이 스팬은 `Next.js` 앱으로 들어오는 각 요청의 루트 스팬을 나타냅니다. 요청의 HTTP 메서드, 경로, 타겟, 상태 코드를 추적합니다.

Attributes:

- [Common HTTP attributes](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/#common-attributes)
  - `http.method`
  - `http.status_code`
- [Server HTTP attributes](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/#http-server-semantic-conventions)
  - `http.route`
  - `http.target`
- `next.span_name`
- `next.span_type`
- `next.route`

### `render route (app) [next.route]`

- `next.span_type`: `AppRender.getBodyResult`.

이 스팬은 앱 라우터에서 경로를 렌더링하는 프로세스를 나타냅니다.

Attributes:

- `next.span_name`
- `next.span_type`
- `next.route`

### `fetch [http.method] [http.url]`

- `next.span_type`: `AppRender.fetch`

이 스팬은 코드에서 실행된 fetch 요청을 나타냅니다.

Attributes:

- [Common HTTP attributes](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/#common-attributes)
  - `http.method`
- [Client HTTP attributes](https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/#http-client)
  - `http.url`
  - `net.peer.name`
  - `net.peer.port` (only if specified)
- `next.span_name`
- `next.span_type`

### `executing api route (app) [next.route]`

- `next.span_type`: `AppRouteRouteHandlers.runHandler`.

이 스팬은 앱 라우터에서 API 라우트 핸들러 실행을 나타냅니다.

Attributes:

- `next.span_name`
- `next.span_type`
- `next.route`

### `getServerSideProps [next.route]`

- `next.span_type`: `Render.getServerSideProps`.

이 스팬은 특정 경로에서 실행된 `getServerSideProps`를 나타냅니다.

Attributes:

- `next.span_name`
- `next.span_type`
- `next.route`

### `getStaticProps [next.route]`

- `next.span_type`: `Render.getStaticProps`.

이 스팬은 특정 경로에서 실행된 `getStaticProps`를 나타냅니다.

Attributes:

- `next.span_name`
- `next.span_type`
- `next.route`

### `render route (pages) [next.route]`

- `next.span_type`: `Render.renderDocument`.

이 스팬은 특정 경로에서 문서를 렌더링하는 프로세스를 나타냅니다.

Attributes:

- `next.span_name`
- `next.span_type`
- `next.route`

### `generateMetadata [next.page]`

- `next.span_type`: `ResolveMetadata.generateMetadata`.

이 스팬은 특정 페이지에서 메타데이터를 생성하는 프로세스를 나타냅니다. 이 스팬은 하나의 경로에 여러개 있을 수 있습니다

Attributes:

- `next.span_name`
- `next.span_type`
- `next.page`
